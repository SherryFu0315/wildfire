path /users {
    read() { true }
    index() { ['email'] }

    /{uid} {
        // `.isAdmin` is not writable by any users including admin user.
        create() { this.isAdmin == null }
        update() { this.isAdmin == null && prior(this).isAdmin == null && isCurrentUser(uid) || isAdmin() }
        delete() { false }
    }
}

path /comments {
    read() { true }
    index() { ['rootCommentId', 'pageURL'] }

    /{commentId} {
        // TODO: Comment should only be created under condition:
        //          this.authorUid == 'anonymous' || this.authorUid == auth.uid
        create() { true }
        update() { false }
        delete() { canDeleteComment(this) || isAdmin() }
    }
}

path /pages {
    read() { true }
    write() { true }
}

path /commentReplies {
    read() { true }
    write() { true }
}

path /votes {
    read() { true }
    write() { true }
    // /{commentId} {
    //     write() {prior(root).}
    // }
    // /{commentId}/{type}/{uid} {
    //     write() { isCurrentUser(uid) || isAdmin() }
    // }

    // Notes:
    //  Ideally, except for admin users,
    //      (1) votes data should only be created by the voting user,
    //      (2) votes data should not be updated by any user,
    //      (3) votes data should only be removed by 
    //          i. it's voter, or 
    //          ii. comment author, or 
    //          iii. root comment author
    //  I'm not declaring these rules at the moment because the votes data
    //  is not that important to have such complex rules. 
    //  Might reconsider this issue in the future though.
}

path /notifications/{uid} {
    read() { isCurrentUser(uid) }

    /{notifId} {
        create() { true }
        update() { isCurrentUser(uid) || isAdmin() }
        delete() { isCurrentUser(uid) || isAdmin() }
    }
}

path /reported {
    read() { isAdmin() }

    /{commentId}/{uid} {
        create() { isCurrentUser(uid) }
        update() { isAdmin() }
        delete() { isAdmin() }
    }
}

path /ban {
    read() { true }
    write() { isAdmin() }
}

// r: read access, c: create access, u: update access, d: delete access
// t: node type [s(single), c(collection)]
path /plugins/{pluginName}/{r}/{c}/{u}/{d} {
    read() { hasAccessComplex(this, r) || isAdmin() }
    create() { hasAccessSimple(this, c) || isAdmin() }
    update() { hasAccessSimple(this, u) || isAdmin() }
    delete() { hasAccessSimple(this, d) || isAdmin() }

    /{nodeName} {
        update() { hasAccessComplex(this, u) || isAdmin() }
        delete() { hasAccessComplex(this, d) || isAdmin() }
    }
}
function hasAccessSimple (this, code) {
    code.includes('a') ?
        true :              
    code.includes('s') ?
        isSignedInUser() :
    // code.includes('x') ?
        false
}
function hasAccessComplex (this, code) {
    code.includes('a') ?
        true :              
    code.includes('s') ?
        isSignedInUser() :  
    code.includes('r') ?
        isRelatedUser(this) :
    code.includes('o') ?
        isOwner(this) :
    // code.includes('x') ?
        false
}

function isCurrentUser (uid) { auth != null && auth.uid == uid }
function isAdmin () { prior(root).users[auth.uid].isAdmin == true }

function isCreate (this) { prior(this) == null }
function isUpdate (this) { this != null && prior(this) != null && this != prior(this)  }
function isDelete (this) { prior(this) != null && this == null }

function canDeleteComment (this) { isCommentAuthor(this) || isRootCommentAuthor(this) }
function isCommentAuthor (this) { prior(this).uid == auth.uid }
function isRootCommentAuthor (this) { prior(this).rootCommentUid == auth.uid }

function isSignedInUser () { auth != null }
function isOwner (this) { isSignedInUser() && (prior(this).owner == auth.uid || (isCreate(this) && this.owner == auth.uid)) }
function isRelatedUser (this) { 
    isSignedInUser() && (prior(this).relatedUsers[auth.uid] != null || isOwner(this))
}